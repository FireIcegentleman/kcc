//
// This file is generated by `llvm-cxxapi` based on LLVM 9.0.0
// , so it may not be compatible with other LLVM versions. If any errors occur
// during compilation, it is recommended that you recompile `llvm-cxxapi` with 
// the specified LLVM version.
// https://github.com/zhangjiantao/llvm-cxxapi
//
// Generate Command:
//
//   llvm-cxxapi -ir=0 -short=0 -o standard.cpp standard.ll
//


#include <llvm/ADT/STLExtras.h>
#include <llvm/IR/IRBuilder.h>
#include <llvm/IR/InlineAsm.h>
#include <llvm/IR/Module.h>
#include <llvm/IR/TypeBuilder.h>
#include <llvm/IR/Verifier.h>
#include <llvm/Support/raw_ostream.h>

#if (LLVM_VERSION_MAJOR != 9 || (LLVM_VERSION_MINOR != 0))
#pragma message("\nwarning : may not be compatible with this LLVM version.\n")
#endif

using namespace llvm;

std::unique_ptr<Module> makeLLVMModule(LLVMContext &);

int main(int argc, char **argv) {
  LLVMContext Ctx;

  auto M = makeLLVMModule(Ctx);
  if (verifyModule(*M)) {
    errs() << "Error: module failed verification.";
    return 1;
  }

  outs() << *M;
  return 0;
}

std::unique_ptr<Module> makeLLVMModule(LLVMContext &Ctx) {
  auto M = llvm::make_unique<Module>("standard.ll", Ctx);
  M->setDataLayout("e-m:e-i64:64-f80:128-n8:16:32:64-S128");
  M->setTargetTriple("x86_64-pc-linux-gnu");
  
  IRBuilder<> IRB(Ctx);
  
  //
  // Type Definitions
  //
  
  auto ArrInt32tTy = TypeBuilder<int32_t[5], false>::get(Ctx);
  
  
  auto FuncTy = TypeBuilder<int32_t(), false>::get(Ctx);
  auto FuncTy1 = TypeBuilder<void(int8_t*, int8_t*, int64_t, types::i<1>), false>::get(Ctx);
  
  
  //
  // Function Declarations
  //
  
  auto FuncMain = Function::Create(FuncTy, GlobalValue::ExternalLinkage, "main", M.get());
  //
  // Global Variable Declarations
  //
  // has initializer, specified below
  auto GlobalArrInt32t = new GlobalVariable(*M, ArrInt32tTy, true, GlobalValue::PrivateLinkage, nullptr);
  GlobalArrInt32t->setName("__const.main.a");
  GlobalArrInt32t->setAlignment(16);
  GlobalArrInt32t->setDSOLocal(true);
  GlobalArrInt32t->setUnnamedAddr(GlobalValue::UnnamedAddr::Global);
  
  //
  // Constant Definitions
  //
  auto ConstArrInt32t = ConstantDataArray::get(Ctx, ArrayRef<uint32_t>({102, 117, 0, 0, 0}));
  auto ConstPtrChar = ConstantExpr::getBitCast(GlobalArrInt32t, Type::getInt8PtrTy(Ctx));
  
  //
  // Global Variable Definitions
  //
  GlobalArrInt32t->setInitializer(ConstArrInt32t);
  
  //
  // Function Definitions
  //
  // Function: main
  if (FuncMain) {
    FuncMain->setDSOLocal(true);
    FuncMain->addFnAttr(Attribute::NoInline);
    FuncMain->addFnAttr(Attribute::NoUnwind);
    FuncMain->addFnAttr(Attribute::OptimizeNone);
    FuncMain->addFnAttr(Attribute::StackProtectStrong);
    FuncMain->addFnAttr(Attribute::UWTable);
    
    // BasicBlocks
    auto Block = BasicBlock::Create(Ctx, "", FuncMain);
    
    //
    // BasicBlock  (Block)
    IRB.SetInsertPoint(Block);
    auto PtrArrInt32t = IRB.CreateAlloca(ArrInt32tTy);
    PtrArrInt32t->setAlignment(16);
    
    